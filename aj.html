<html>
<title>Sign JWTs with WebCrypto in Vanilla JS</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<script>
// Configure your application and authorization server details
var config = {
    // client_id: "https://app.mornemaritz.tech/myappid#this",
    client_id: "7479b187-60e8-4820-a4f5-a6d66d23d7d8",
    redirect_uri: "http://localhost:1234/",
    authorization_endpoint: "https://login.inrupt.com/authorization",
    token_endpoint: "https://login.inrupt.com/token",
    requested_scopes: "openid offline_access"
};
</script>

<div class="full-height">
    <div class="content">
        <a href="#" id="start">Click to Generate JWT</a>
        <div id="token" class="hidden">
            <h2>JWT</h2>
            <div id="access_token" class="code"></div>
        </div>
        <div id="error" class="hidden">
            <h2>Error</h2>
            <div id="error_details" class="code"></div>
        </div>
    </div>
</div>  
<script>

/*
Combination of 
https://coolaj86.com/articles/sign-jwt-webcrypto-vanilla-js/
https://github.com/aaronpk/pkce-vanilla-js/blob/master/index.html
*/

document.getElementById("start").addEventListener("click", function(e){
    e.preventDefault();

    // var claims = {
    //     iss: 'https://example.com/',
    //     sub: 'xxx',
    //     azp: 'https://cool.io/',
    //     aud: 'https://example.com/',
    //     exp: Math.round(Date.now() / 1000) + 15 * 60
    // };

    // tokenBody
    let claims = {
        "htu": config.token_endpoint,
        "htm": "POST",
        "jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8",
        "iat": Math.round(Date.now() / 1000)
    }

    EC.generate()
    .then(function(jwk) {
        console.info('Private Key:', JSON.stringify(jwk));
        console.info('Public Key:', JSON.stringify(EC.neuter(jwk)));

        return JWK.thumbprint(jwk)
        .then(function(kid) {
            // return JWT.sign(jwk, { kid: kid }, claims)
            return JWT.sign(jwk, {}, claims)
            .then(function(jwt) {
                console.info('JWT:', jwt);

                document.getElementById("access_token").innerText = jwt;
                document.getElementById("start").classList = "hidden";
                document.getElementById("token").classList = "";
            })
            .catch(function(e) {
                console.error(e);

                document.getElementById("error_details").innerText = error.error+"\n\n"+error.error_description;
                document.getElementById("error").classList = "";    

            });
        })    
        .catch(function(e) {
            console.error(e);

            document.getElementById("error_details").innerText = error.error+"\n\n"+error.error_description;
            document.getElementById("error").classList = "";

        });    
    })    
    .catch(function(e) {
        console.error(e);

        document.getElementById("error_details").innerText = error.error+"\n\n"+error.error_description;
        document.getElementById("error").classList = "";

    });    

});    


var JWT = {};
JWT.sign = function(jwk, headers, claims) {
    // Make a shallow copy of the key
    // (to set ext if it wasn't already set)
    jwk = Object.assign({}, jwk);

    // The headers should probably be empty
    // headers.typ = 'JWT';
    headers.typ = 'dpop+jwt';
    headers.alg = 'ES256';
    if (!headers.kid) {
        // alternate: see thumbprint function below
        headers.jwk = { kty: jwk.kty, crv: jwk.crv, x: jwk.x, y: jwk.y };
    }

    var jws = {
        // JWT "headers" really means JWS "protected headers"
        protected: strToUrlBase64(JSON.stringify(headers)),

        // JWT "claims" are really a JSON-defined JWS "payload"
        payload: strToUrlBase64(JSON.stringify(claims))
    };

    // To import as EC (ECDSA, P-256, SHA-256, ES256)
    var keyType = {
        name: 'ECDSA',
        namedCurve: 'P-256',
        hash: { name: 'SHA-256' }
    };

    // To make re-exportable as JSON (or DER/PEM)
    var exportable = true;

    // Import as a private key that isn't black-listed from signing
    var privileges = ['sign'];

    // Actually do the import, which comes out as an abstract key type
    return window.crypto.subtle
        .importKey('jwk', jwk, keyType, exportable, privileges)
        .then(function(privkey) {
            // Convert UTF-8 to Uint8Array ArrayBuffer
            var data = strToUint8(jws.protected + '.' + jws.payload);

            // The signature and hash should match the bit-entropy of the key
            // https://tools.ietf.org/html/rfc7518#section-3
            var sigType = { name: 'ECDSA', hash: { name: 'SHA-256' } };

            return window.crypto.subtle.sign(sigType, privkey, data).then(function(signature) {
                // returns an ArrayBuffer containing a JOSE (not X509) signature,
                // which must be converted to Uint8 to be useful
                jws.signature = uint8ToUrlBase64(new Uint8Array(signature));

                // JWT is just a "compressed", "protected" JWS
                return jws.protected + '.' + jws.payload + '.' + jws.signature;
            });
        });
};

var EC = {};
EC.generate = function() {
    var keyType = {
        name: 'ECDSA',
        namedCurve: 'P-256'
    };
    var exportable = true;
    var privileges = ['sign', 'verify'];
    return window.crypto.subtle.generateKey(keyType, exportable, privileges).then(function(key) {
        // returns an abstract and opaque WebCrypto object,
        // which in most cases you'll want to export as JSON to be able to save
        return window.crypto.subtle.exportKey('jwk', key.privateKey);
    });
};

// Create a Public Key from a Private Key
//
// chops off the private parts
EC.neuter = function(jwk) {
    var copy = Object.assign({}, jwk);
    delete copy.d;
    copy.key_ops = ['verify'];
    return copy;
};

var JWK = {};
JWK.thumbprint = function(jwk) {
    // lexigraphically sorted, no spaces
    var sortedPub = '{"crv":"CRV","kty":"EC","x":"X","y":"Y"}'
        .replace('CRV', jwk.crv)
        .replace('X', jwk.x)
        .replace('Y', jwk.y);

    // The hash should match the size of the key,
    // but we're only dealing with P-256
    return window.crypto.subtle
        .digest({ name: 'SHA-256' }, strToUint8(sortedPub))
        .then(function(hash) {
            return uint8ToUrlBase64(new Uint8Array(hash));
        });
};

// String (UCS-2) to Uint8Array
//
// because... JavaScript, Strings, and Buffers
function strToUint8(str) {
    return new TextEncoder().encode(str);
}

// // Same thing, without TextEncoder:
// function strToUint8(str) {
//     return new Uint8Array.from(
//         utf8ToBinaryString(str)
//             .split('')
//             .forEach(function(ch) {
//                 return ch.charCodeAt(0);
//             })
//     );
// }

// UCS-2 String to URL-Safe Base64
//
// btoa doesn't work on UTF-8 strings
function strToUrlBase64(str) {
    return binToUrlBase64(utf8ToBinaryString(str));
}

// Binary String to URL-Safe Base64
//
// btoa (Binary-to-Ascii) means "binary string" to base64
function binToUrlBase64(bin) {
    return btoa(bin)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+/g, '');
}

// UTF-8 to Binary String
//
// Because JavaScript has a strange relationship with strings
// https://coolaj86.com/articles/base64-unicode-utf-8-javascript-and-you/
function utf8ToBinaryString(str) {
    var escstr = encodeURIComponent(str);
    // replaces any uri escape sequence, such as %0A,
    // with binary escape, such as 0x0A
    var binstr = escstr.replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode(parseInt(p1, 16));
    });

    return binstr;
}

// Uint8Array to URL Safe Base64
//
// the shortest distant between two encodings... binary string
function uint8ToUrlBase64(uint8) {
    var bin = '';
    uint8.forEach(function(code) {
        bin += String.fromCharCode(code);
    });
    return binToUrlBase64(bin);
}

</script>

<style>
body {
  padding: 0;
  margin: 0;
  min-height: 100vh;
  font-family: arial, sans-serif;
}
@media(max-width: 400px) {
  body {
    padding: 10px;
  }
}
.full-height {
  min-height: 100vh;
}
.flex-center {
  align-items: center;
  display: flex;
  justify-content: center;
}
.content {
  max-width: 400px;
}
h2 {
  text-align: center;
}
.code {
  font-family: "Courier New", "Courier", monospace;
  width: 100%;
  padding: 4px;
  border: 1px #ccc solid;
  border-radius: 4px;
  word-break: break-all;
}
.hidden {
  display: none;
}
</style>

</html>